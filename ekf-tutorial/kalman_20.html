
<!DOCTYPE html>
<html>
<head><script type="text/javascript" src="/_static/js/bundle-playback.js?v=1WaXNDFE" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=txqj7nKC" charset="utf-8"></script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=S1zqJCYt" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->


<title>The Extended Kalman Filter: An Interactive Tutorial</title>

<script src="utils.js" type="text/javascript"></script>

<script type="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full"></script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

<script type="text/javascript">

function init() {

}

</script>

</head>

<body onload="init();">

<h1>The Extended Kalman Filter: An Interactive Tutorial for Non-Experts</h1>

<h3>Part 20: TinyEKF</h3>

If you've come this far, you're ready to start experimenting with an actual EKF implementation.

<p>

<a href="https://github.com/simondlevy/TinyEKF">TinyEKF</a> is a simple C/C++ implementation that I wrote primarily for 
running on a microcontroller like 
<a href="https://arduino.cc/">Arduino</a>, <a href="/https://www.pjrc.com/teensy/">Teensy</a>, 
and the <a href="https://en.wikipedia.org/wiki/STM32">STM32</a> line used in most modern flight controllers.
Having looked over the EKF code in some of these flight controllers,
I found the code difficult to relate to the understanding expressed in this tutorial.  So I decided to write a simple EKF implementation
that would be practical to use on an actual microcontroller, taking up a &ldquo;tiny&rdquo; amount of memory, while still
being flexible enough to use on different projects.  I also wrote a Python implementation, so you can prototype your EKF
before running it on an actual microcontroller.

<p>

TinyEKF requires you to write only a single <tt>model</tt> function, filling in the values of the state-transition function $f(x)$, 
its Jacobian matrix $F(x)$, the sensor function $h(x)$, and its Jacobian $H(x)$.  The prediction and update then handled automatically
by passing the observation vector $z$ to the <tt>step</tt> function.  

<p>

Three examples are provided: 
<ol>
<li> a pure C example using GPS satellite data stored in a file, based on You Chong's 
<a href="https://www.mathworks.com/matlabcentral/fileexchange/31487-extended-kalman-filter-ekf--for-gps">Matlab implementation</a>
<p><li> a C++ sensor-fusion example that runs on Arduino
<p><li> a Python mouse-tracking example (requires OpenCV)
</ul>

<h3> 
    <p>Previous: <a href="kalman_19.html" rel="next">The Jacobian</a>
</h3>


</body>
</html>
